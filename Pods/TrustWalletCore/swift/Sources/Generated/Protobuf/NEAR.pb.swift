// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: NEAR.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct TW_NEAR_Proto_PublicKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keyType: UInt32 = 0

  public var data: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_NEAR_Proto_FunctionCallPermission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// uint128
  public var allowance: Data = SwiftProtobuf.Internal.emptyData

  public var receiverID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_NEAR_Proto_FullAccessPermission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_NEAR_Proto_AccessKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nonce: UInt64 {
    get {return _storage._nonce}
    set {_uniqueStorage()._nonce = newValue}
  }

  public var permission: OneOf_Permission? {
    get {return _storage._permission}
    set {_uniqueStorage()._permission = newValue}
  }

  public var functionCall: TW_NEAR_Proto_FunctionCallPermission {
    get {
      if case .functionCall(let v)? = _storage._permission {return v}
      return TW_NEAR_Proto_FunctionCallPermission()
    }
    set {_uniqueStorage()._permission = .functionCall(newValue)}
  }

  public var fullAccess: TW_NEAR_Proto_FullAccessPermission {
    get {
      if case .fullAccess(let v)? = _storage._permission {return v}
      return TW_NEAR_Proto_FullAccessPermission()
    }
    set {_uniqueStorage()._permission = .fullAccess(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Permission: Equatable {
    case functionCall(TW_NEAR_Proto_FunctionCallPermission)
    case fullAccess(TW_NEAR_Proto_FullAccessPermission)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_NEAR_Proto_AccessKey.OneOf_Permission, rhs: TW_NEAR_Proto_AccessKey.OneOf_Permission) -> Bool {
      switch (lhs, rhs) {
      case (.functionCall(let l), .functionCall(let r)): return l == r
      case (.fullAccess(let l), .fullAccess(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct TW_NEAR_Proto_CreateAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_NEAR_Proto_DeployContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_NEAR_Proto_FunctionCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var methodName: Data = SwiftProtobuf.Internal.emptyData

  public var args: Data = SwiftProtobuf.Internal.emptyData

  public var gas: UInt64 = 0

  /// uint128
  public var deposit: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_NEAR_Proto_Transfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// uint128
  public var deposit: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_NEAR_Proto_Stake {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// uint128
  public var stake: Data = SwiftProtobuf.Internal.emptyData

  public var publicKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_NEAR_Proto_AddKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var publicKey: TW_NEAR_Proto_PublicKey {
    get {return _storage._publicKey ?? TW_NEAR_Proto_PublicKey()}
    set {_uniqueStorage()._publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  public var hasPublicKey: Bool {return _storage._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPublicKey() {_uniqueStorage()._publicKey = nil}

  public var accessKey: TW_NEAR_Proto_AccessKey {
    get {return _storage._accessKey ?? TW_NEAR_Proto_AccessKey()}
    set {_uniqueStorage()._accessKey = newValue}
  }
  /// Returns true if `accessKey` has been explicitly set.
  public var hasAccessKey: Bool {return _storage._accessKey != nil}
  /// Clears the value of `accessKey`. Subsequent reads from it will return its default value.
  public mutating func clearAccessKey() {_uniqueStorage()._accessKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct TW_NEAR_Proto_DeleteKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var publicKey: TW_NEAR_Proto_PublicKey {
    get {return _storage._publicKey ?? TW_NEAR_Proto_PublicKey()}
    set {_uniqueStorage()._publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  public var hasPublicKey: Bool {return _storage._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPublicKey() {_uniqueStorage()._publicKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct TW_NEAR_Proto_DeleteAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var beneficiaryID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_NEAR_Proto_Action {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var createAccount: TW_NEAR_Proto_CreateAccount {
    get {
      if case .createAccount(let v)? = _storage._payload {return v}
      return TW_NEAR_Proto_CreateAccount()
    }
    set {_uniqueStorage()._payload = .createAccount(newValue)}
  }

  public var deployContract: TW_NEAR_Proto_DeployContract {
    get {
      if case .deployContract(let v)? = _storage._payload {return v}
      return TW_NEAR_Proto_DeployContract()
    }
    set {_uniqueStorage()._payload = .deployContract(newValue)}
  }

  public var functionCall: TW_NEAR_Proto_FunctionCall {
    get {
      if case .functionCall(let v)? = _storage._payload {return v}
      return TW_NEAR_Proto_FunctionCall()
    }
    set {_uniqueStorage()._payload = .functionCall(newValue)}
  }

  public var transfer: TW_NEAR_Proto_Transfer {
    get {
      if case .transfer(let v)? = _storage._payload {return v}
      return TW_NEAR_Proto_Transfer()
    }
    set {_uniqueStorage()._payload = .transfer(newValue)}
  }

  public var stake: TW_NEAR_Proto_Stake {
    get {
      if case .stake(let v)? = _storage._payload {return v}
      return TW_NEAR_Proto_Stake()
    }
    set {_uniqueStorage()._payload = .stake(newValue)}
  }

  public var addKey: TW_NEAR_Proto_AddKey {
    get {
      if case .addKey(let v)? = _storage._payload {return v}
      return TW_NEAR_Proto_AddKey()
    }
    set {_uniqueStorage()._payload = .addKey(newValue)}
  }

  public var deleteKey: TW_NEAR_Proto_DeleteKey {
    get {
      if case .deleteKey(let v)? = _storage._payload {return v}
      return TW_NEAR_Proto_DeleteKey()
    }
    set {_uniqueStorage()._payload = .deleteKey(newValue)}
  }

  public var deleteAccount: TW_NEAR_Proto_DeleteAccount {
    get {
      if case .deleteAccount(let v)? = _storage._payload {return v}
      return TW_NEAR_Proto_DeleteAccount()
    }
    set {_uniqueStorage()._payload = .deleteAccount(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case createAccount(TW_NEAR_Proto_CreateAccount)
    case deployContract(TW_NEAR_Proto_DeployContract)
    case functionCall(TW_NEAR_Proto_FunctionCall)
    case transfer(TW_NEAR_Proto_Transfer)
    case stake(TW_NEAR_Proto_Stake)
    case addKey(TW_NEAR_Proto_AddKey)
    case deleteKey(TW_NEAR_Proto_DeleteKey)
    case deleteAccount(TW_NEAR_Proto_DeleteAccount)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_NEAR_Proto_Action.OneOf_Payload, rhs: TW_NEAR_Proto_Action.OneOf_Payload) -> Bool {
      switch (lhs, rhs) {
      case (.createAccount(let l), .createAccount(let r)): return l == r
      case (.deployContract(let l), .deployContract(let r)): return l == r
      case (.functionCall(let l), .functionCall(let r)): return l == r
      case (.transfer(let l), .transfer(let r)): return l == r
      case (.stake(let l), .stake(let r)): return l == r
      case (.addKey(let l), .addKey(let r)): return l == r
      case (.deleteKey(let l), .deleteKey(let r)): return l == r
      case (.deleteAccount(let l), .deleteAccount(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Input data necessary to create a signed order.
public struct TW_NEAR_Proto_SigningInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var signerID: String = String()

  public var nonce: UInt64 = 0

  public var receiverID: String = String()

  public var blockHash: Data = SwiftProtobuf.Internal.emptyData

  public var actions: [TW_NEAR_Proto_Action] = []

  public var privateKey: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Transaction signing output.
public struct TW_NEAR_Proto_SigningOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Signed transaction blob
  public var signedTransaction: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TW.NEAR.Proto"

extension TW_NEAR_Proto_PublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_type"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.keyType)
      case 2: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyType != 0 {
      try visitor.visitSingularUInt32Field(value: self.keyType, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_PublicKey, rhs: TW_NEAR_Proto_PublicKey) -> Bool {
    if lhs.keyType != rhs.keyType {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_FunctionCallPermission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FunctionCallPermission"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "allowance"),
    2: .standard(proto: "receiver_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.allowance)
      case 2: try decoder.decodeSingularStringField(value: &self.receiverID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowance.isEmpty {
      try visitor.visitSingularBytesField(value: self.allowance, fieldNumber: 1)
    }
    if !self.receiverID.isEmpty {
      try visitor.visitSingularStringField(value: self.receiverID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_FunctionCallPermission, rhs: TW_NEAR_Proto_FunctionCallPermission) -> Bool {
    if lhs.allowance != rhs.allowance {return false}
    if lhs.receiverID != rhs.receiverID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_FullAccessPermission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FullAccessPermission"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_FullAccessPermission, rhs: TW_NEAR_Proto_FullAccessPermission) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_AccessKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .standard(proto: "function_call"),
    3: .standard(proto: "full_access"),
  ]

  fileprivate class _StorageClass {
    var _nonce: UInt64 = 0
    var _permission: TW_NEAR_Proto_AccessKey.OneOf_Permission?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _nonce = source._nonce
      _permission = source._permission
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._nonce)
        case 2:
          var v: TW_NEAR_Proto_FunctionCallPermission?
          if let current = _storage._permission {
            try decoder.handleConflictingOneOf()
            if case .functionCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._permission = .functionCall(v)}
        case 3:
          var v: TW_NEAR_Proto_FullAccessPermission?
          if let current = _storage._permission {
            try decoder.handleConflictingOneOf()
            if case .fullAccess(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._permission = .fullAccess(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._nonce != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._nonce, fieldNumber: 1)
      }
      switch _storage._permission {
      case .functionCall(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .fullAccess(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_AccessKey, rhs: TW_NEAR_Proto_AccessKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._nonce != rhs_storage._nonce {return false}
        if _storage._permission != rhs_storage._permission {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_CreateAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateAccount"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_CreateAccount, rhs: TW_NEAR_Proto_CreateAccount) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_DeployContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeployContract"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularBytesField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_DeployContract, rhs: TW_NEAR_Proto_DeployContract) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_FunctionCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FunctionCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "method_name"),
    2: .same(proto: "args"),
    3: .same(proto: "gas"),
    4: .same(proto: "deposit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.methodName)
      case 2: try decoder.decodeSingularBytesField(value: &self.args)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.gas)
      case 4: try decoder.decodeSingularBytesField(value: &self.deposit)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.methodName.isEmpty {
      try visitor.visitSingularBytesField(value: self.methodName, fieldNumber: 1)
    }
    if !self.args.isEmpty {
      try visitor.visitSingularBytesField(value: self.args, fieldNumber: 2)
    }
    if self.gas != 0 {
      try visitor.visitSingularUInt64Field(value: self.gas, fieldNumber: 3)
    }
    if !self.deposit.isEmpty {
      try visitor.visitSingularBytesField(value: self.deposit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_FunctionCall, rhs: TW_NEAR_Proto_FunctionCall) -> Bool {
    if lhs.methodName != rhs.methodName {return false}
    if lhs.args != rhs.args {return false}
    if lhs.gas != rhs.gas {return false}
    if lhs.deposit != rhs.deposit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_Transfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transfer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deposit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.deposit)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deposit.isEmpty {
      try visitor.visitSingularBytesField(value: self.deposit, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_Transfer, rhs: TW_NEAR_Proto_Transfer) -> Bool {
    if lhs.deposit != rhs.deposit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_Stake: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Stake"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stake"),
    2: .standard(proto: "public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.stake)
      case 2: try decoder.decodeSingularStringField(value: &self.publicKey)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stake.isEmpty {
      try visitor.visitSingularBytesField(value: self.stake, fieldNumber: 1)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_Stake, rhs: TW_NEAR_Proto_Stake) -> Bool {
    if lhs.stake != rhs.stake {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_AddKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .standard(proto: "access_key"),
  ]

  fileprivate class _StorageClass {
    var _publicKey: TW_NEAR_Proto_PublicKey? = nil
    var _accessKey: TW_NEAR_Proto_AccessKey? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _publicKey = source._publicKey
      _accessKey = source._accessKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._publicKey)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._accessKey)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._publicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._accessKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_AddKey, rhs: TW_NEAR_Proto_AddKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._publicKey != rhs_storage._publicKey {return false}
        if _storage._accessKey != rhs_storage._accessKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_DeleteKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
  ]

  fileprivate class _StorageClass {
    var _publicKey: TW_NEAR_Proto_PublicKey? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _publicKey = source._publicKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._publicKey)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._publicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_DeleteKey, rhs: TW_NEAR_Proto_DeleteKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._publicKey != rhs_storage._publicKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_DeleteAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAccount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "beneficiary_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.beneficiaryID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.beneficiaryID.isEmpty {
      try visitor.visitSingularStringField(value: self.beneficiaryID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_DeleteAccount, rhs: TW_NEAR_Proto_DeleteAccount) -> Bool {
    if lhs.beneficiaryID != rhs.beneficiaryID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "create_account"),
    2: .standard(proto: "deploy_contract"),
    3: .standard(proto: "function_call"),
    4: .same(proto: "transfer"),
    5: .same(proto: "stake"),
    6: .standard(proto: "add_key"),
    7: .standard(proto: "delete_key"),
    8: .standard(proto: "delete_account"),
  ]

  fileprivate class _StorageClass {
    var _payload: TW_NEAR_Proto_Action.OneOf_Payload?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: TW_NEAR_Proto_CreateAccount?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .createAccount(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .createAccount(v)}
        case 2:
          var v: TW_NEAR_Proto_DeployContract?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .deployContract(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .deployContract(v)}
        case 3:
          var v: TW_NEAR_Proto_FunctionCall?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .functionCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .functionCall(v)}
        case 4:
          var v: TW_NEAR_Proto_Transfer?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .transfer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .transfer(v)}
        case 5:
          var v: TW_NEAR_Proto_Stake?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .stake(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .stake(v)}
        case 6:
          var v: TW_NEAR_Proto_AddKey?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .addKey(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .addKey(v)}
        case 7:
          var v: TW_NEAR_Proto_DeleteKey?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .deleteKey(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .deleteKey(v)}
        case 8:
          var v: TW_NEAR_Proto_DeleteAccount?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .deleteAccount(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .deleteAccount(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._payload {
      case .createAccount(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .deployContract(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .functionCall(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .transfer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .stake(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .addKey(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .deleteKey(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .deleteAccount(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_Action, rhs: TW_NEAR_Proto_Action) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_SigningInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigningInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signer_id"),
    2: .same(proto: "nonce"),
    3: .standard(proto: "receiver_id"),
    4: .standard(proto: "block_hash"),
    5: .same(proto: "actions"),
    6: .standard(proto: "private_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.signerID)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.nonce)
      case 3: try decoder.decodeSingularStringField(value: &self.receiverID)
      case 4: try decoder.decodeSingularBytesField(value: &self.blockHash)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.actions)
      case 6: try decoder.decodeSingularBytesField(value: &self.privateKey)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signerID.isEmpty {
      try visitor.visitSingularStringField(value: self.signerID, fieldNumber: 1)
    }
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 2)
    }
    if !self.receiverID.isEmpty {
      try visitor.visitSingularStringField(value: self.receiverID, fieldNumber: 3)
    }
    if !self.blockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockHash, fieldNumber: 4)
    }
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 5)
    }
    if !self.privateKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKey, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_SigningInput, rhs: TW_NEAR_Proto_SigningInput) -> Bool {
    if lhs.signerID != rhs.signerID {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.receiverID != rhs.receiverID {return false}
    if lhs.blockHash != rhs.blockHash {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_SigningOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigningOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signed_transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.signedTransaction)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signedTransaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedTransaction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_SigningOutput, rhs: TW_NEAR_Proto_SigningOutput) -> Bool {
    if lhs.signedTransaction != rhs.signedTransaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
